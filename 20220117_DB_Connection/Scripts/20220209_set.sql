--SET Operation
-- 다른 쿼리를 붙여서 출력해 줄 수 있다
-- 단, 1)order by는 맨 마지막에 작성해야 한다
--    2)같은 타입의 컬럼이 출력되어야 한다
--    3)컬럼명은 선택 테이블의 명으로 정해 짐
--UNION : 중복되는 ROW를 제거하고 표현
--UNION ALL : 두개의 쿼리를 단순히 붙여줌
--INTERSECT  : 교차 되는 값을 출력
--MINUS  : 선행 테이블에서 교차되는 값을 제거한 순수한 선행 ROW만을 출력

-- 축구 선수들 정보 중에서 K02와 K07의 선수들의 정보를 출력
SELECT *
	FROM PLAYER p 
		WHERE TEAM_ID IN('K02','K07');

SELECT *
	FROM PLAYER p 
	WHERE TEAM_ID = 'K02'
UNION
SELECT *
	FROM PLAYER p 
		WHERE TEAM_ID = 'K07';

-- 출력 타입이 같아야 한다. -- 컬럼명은 선택 테이블로 작성된다.
SELECT PLAYER_ID , TEAM_ID ,'1',1 AS 등번호
	FROM PLAYER p 
	WHERE TEAM_ID = 'K02'
UNION
SELECT PLAYER_NAME , TEAM_ID , "POSITION"  , NVL(BACK_NO,99) 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K07'
		ORDER BY 1;-- UNION 에서 ORDER BY 는 문장의 맨 마지막에 작성되어야 함;

-- DB에서는 NULL이 가장 큰값으로 나옴 . 숫자->문자->NULL
-- JAVA에서는 [] 순서 SORT NULL이 맨앞에 나온다.
SELECT COMM
	FROM EMP e 
	ORDER BY COMM DESC ;


--1) K-리그 소속 선수들 중에서 소속이 삼성블루윙즈팀 인 선수들과
--   전남드레곤즈팀인 선수들에 대한 내용을 모두보고 싶다.

SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키
	FROM PLAYER p 
	WHERE TEAM_ID ='K02'
UNION 
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키
	FROM PLAYER p 
	WHERE TEAM_ID ='K07';
--2) K- 리그 소속 선수들 중에서 소속이 삼성블루윙즈팀인 선수들과
--   포지션이 골커퍼 (GK) 인 선수들을 모두 보고 싶다. 
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
	WHERE TEAM_ID  = 'K02'
UNION 
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
	WHERE "POSITION" = 'GK'
--	ORDER BY "POSITION" ,1;
	ORDER BY 포지션 ,1;
-- 기존의 ORDER BY : INDEX, 컬럼, ALIAS 명 선택 가능
-- UNION에서의 ORDER BY 는 ALIAS와 INDEX 만 작동
-- UNION은 같은 값이라면 제거하고 출력
-- UNION인 경우 : K02(49) + GK(43) => 92 -4 (K02 이면서 GK) 
-- UNION ALL인 경우 : K02(45) + GK(43)+ K02이면서GK(4) => 92
-- 교차인 4명 INTERSECT 를 통해서 검색할 수 있다.
-- 검색되는 테이블의 조건 TEAM_ID 와

SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p --481
UNION
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p2 --43
	WHERE "POSITION" = 'GK';

SELECT *
	FROM PLAYER p2 
		WHERE TEAM_ID = 'K02'OR "POSITION" ='GK'
		ORDER BY "POSITION" , TEAM_ID ;
--3) K-리그 소속 선수들에 대한 정보 중에서 포지션별 평균키와
--   팀별 평균키를 알고 싶다.
SELECT "POSITION" , AVG(HEIGHT) 
	FROM PLAYER p
	GROUP BY "POSITION" 
UNION 
SELECT  TEAM_ID , AVG(HEIGHT) 
	FROM PLAYER p
	GROUP BY TEAM_ID 
	ORDER BY 1;
--문제점 : ~별은 절대 같은 쿼리로 동작을 시킬 수 없다. 집계함수(SUM,AVG,COUNT...)
SELECT "POSITION" , TEAM_ID , AVG(HEIGHT) 
	FROM PLAYER p 
	GROUP BY TEAM_ID , "POSITION" ;
-- GROUP BY 묶어서 처리
-- TEAM_ID 따로 POSITION 따로 된게 아니고 TEAM_ID AND POSITION 인 묶음으로 나타냄
SELECT "POSITION" || TEAM_ID  
	FROM PLAYER p;


--4) K-리그 소속 선수를 중에서 소속이 삼성블루윙즈팀이면서
--   포지션이 미드필더 (MF)가 아닌 선수들의 정보를 보고 싶다.
SELECT  TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
	WHERE TEAM_ID = 'K02' AND "POSITION" !='MF';
-- 전체 결과에서 차집합
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K02';
	
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K02' AND "POSITION" ='MF';
	
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K02'
MINUS
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE "POSITION" ='MF';
--5) K-리그 소속 선수들 중에서 소속이 삼성블루윙즈팀이면서
--   포지션이 골키퍼 (GK) 인 선수들의 정보를 보고 싶다.
	
-- K02인 선수들 중에서 GK를 선택하고 출력
-- K02인 선수들 중에서 MF, FW, DF인 선수들을 제외 하면 됨

-- 비효율적이 아니다 가독성이 떨어진다.
SELECT *
	FROM PLAYER p 
		WHERE TEAM_ID ='K02' AND "POSITION" ='GK';
	
SELECT *
	FROM PLAYER p 
		WHERE TEAM_ID ='K02' AND "POSITION" NOT IN('MF','FW','DF');
	
SELECT *
	FROM PLAYER p 
		WHERE TEAM_ID ='K02' AND NOT "POSITION"  IN('MF','FW','DF');

	
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K02'
INTERSECT 
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE "POSITION" ='GK';
	
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE TEAM_ID = 'K02'
MINUS 
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, "POSITION" 포지션 , BACK_NO 백넘버, HEIGHT 키 
	FROM PLAYER p 
		WHERE "POSITION" !='GK';

----------------------------------------------
--3일차 오라클 과제
	
SELECT *
	FROM SAL_GRADE sg ;

--1
SELECT EMPNO ,ENAME ,SAL, GRADE
	FROM EMP e JOIN SAL_GRADE sg 
	ON SAL BETWEEN LOSAL AND HISAL;
--2
-- 서브쿼리 주의점 반드시 ()괄호로 묶어줘야함
SELECT EMPNO, ENAME , JOB , SAL 
	FROM EMP e 
	WHERE SAL > (SELECT AVG(SAL) FROM EMP e2)
	ORDER BY SAL DESC;
--3
SELECT d.DNAME , EMPNO , ENAME, JOB, e.SAL
	FROM EMP e , DEPT d , ( SELECT DEPTNO ,AVG(SAL) SAL
					 	FROM EMP
					 		WHERE DEPTNO IS NOT NULL
								GROUP BY DEPTNO) e2
		WHERE e.DEPTNO = e2.DEPTNO 
		AND e.SAL > e2.SAL
		AND e.DEPTNO = d.DEPTNO
			ORDER BY e.SAL DESC; -- COST: 9


SELECT DNAME ,EMPNO, ENAME , JOB , SAL 
	FROM EMP e JOIN DEPT d 
	USING(DEPTNO)
	WHERE SAL > (SELECT AVG(SAL) FROM EMP e2) -- SUBQUERY는 EMP 테이블의 전체 평균. 틀림 -> 부서별
	ORDER BY SAL DESC;

SELECT d.DNAME  ,EMPNO, ENAME , JOB , SAL
	FROM EMP e, DEPT d
	WHERE e.DEPTNO  = d.DEPTNO 
		AND SAL>(SELECT AVG(SAL)
					FROM EMP e2
					WHERE e.DEPTNO = e2.DEPTNO)
		ORDER BY SAL DESC;
--4
SELECT GRADE, LOSAL , HISAL , COUNT(GRADE) AS CNT
	FROM EMP e JOIN SAL_GRADE sg 
	ON SAL BETWEEN LOSAL AND HISAL
	GROUP BY GRADE ,LOSAL ,HISAL ;

SELECT GRADE, LOSAL , HISAL
	FROM EMP e JOIN SAL_GRADE sg 
	ON SAL BETWEEN LOSAL AND HISAL;

SELECT sg.GRADE , LOSAL , HISAL , c.CNT
	FROM SAL_GRADE sg  
	JOIN (SELECT sg.GRADE, COUNT(sg.GRADE) CNT  
			FROM EMP e JOIN SAL_GRADE sg
			ON e.SAL BETWEEN sg.LOSAL AND sg.HISAL 
			GROUP BY sg.GRADE	
			ORDER BY sg.GRADE) c
	ON sg.GRADE = c.GRADE; -- COST : 3

--5
SELECT DNAME, LOC, EMPNO , ENAME 
	FROM EMP e JOIN DEPT d 
	USING(DEPTNO)
	WHERE DNAME = 'RESEARCH' OR LOC = 'NEW YORK'
	ORDER BY DNAME ;

SELECT  DNAME, LOC, EMPNO , ENAME 
	FROM EMP e1 JOIN DEPT d1
		ON e1.DEPTNO  = d1.DEPTNO 
	WHERE  d1.DNAME  = 'RESEARCH'
		OR d1.LOC  = 'NEW YORK'
	ORDER BY DNAME ASC;


----------------------------------------------------
--4일차

--1.
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO
	FROM ( SELECT * FROM EMP e ORDER BY SAL DESC) -- FROM 절에서 ROW를 읽으면서 순서를 작성해준다.
	WHERE ROWNUM<=5;

--2.
-- 나중에 PAGING 처리 할 때 필요한 코드, 게시판에서 특정한 순서로 정렬을 하고 10개 5개
SELECT  EMPNO , ENAME , JOB , MGR , HIREDATE , SAL , COMM , DEPTNO, RM
	FROM (
		SELECT EMPNO , ENAME , JOB , MGR , HIREDATE , SAL , COMM , DEPTNO , ROWNUM RM
			FROM(
				SELECT EMPNO , ENAME , JOB , MGR , HIREDATE , SAL , COMM , DEPTNO 
					FROM EMP e 
					ORDER BY SAL DESC)
			)
		WHERE RM BETWEEN 6 AND 10;
	
SELECT EMPNO , ENAME , JOB , MGR , HIREDATE , SAL , COMM , DEPTNO, RM
	FROM(
		SELECT EMPNO , ENAME , JOB , MGR , HIREDATE , SAL , COMM , DEPTNO, ROW_NUMBER () OVER(ORDER BY SAL DESC) RM 
			FROM EMP e)
	WHERE RM BETWEEN 6 AND 10; 

--3.
--SELECT ROWNUM, A.* 
--FROM   EMP A
--WHERE  ROWNUM > 5

--정답 : ROWNUM 은 FROM의 결과에 따라서 동적으로 부여되는 번호
--      위의 쿼리는 처음 데이터가 들어 갔을때 ROWNUM은 1이 부여되어야 된다.
--      하지만 5보다 크다는 조건은 만족할 수 있는 작은 값이 생성되지 않았기 때문에
--      1이상의 값이 증가 되지 않기 때문에 5가 될 수 없고 0이 출력된다.

--4.
SELECT 
	MAX(CASE GRADE WHEN 1 THEN LOSAL ||'~'||HISAL  END) GRADE_1,
	MAX(CASE GRADE WHEN 2 THEN LOSAL ||'~'||HISAL  END) GRADE_2,
	MAX(CASE GRADE WHEN 3 THEN LOSAL ||'~'||HISAL  END) GRADE_3,
	MAX(CASE GRADE WHEN 4 THEN LOSAL ||'~'||HISAL  END) GRADE_4,
	MAX(CASE GRADE WHEN 5 THEN LOSAL ||'~'||HISAL  END) GRADE_5
	FROM SAL_GRADE sg;

SELECT 
	CASE LOSAL WHEN 700  THEN LOSAL||'~'||HISAL END GRADE_1,
	CASE LOSAL WHEN 1201 THEN LOSAL||'~'||HISAL END GRADE_2,
	CASE LOSAL WHEN 1401 THEN LOSAL||'~'||HISAL END GRADE_3,
	CASE LOSAL WHEN 2001 THEN LOSAL||'~'||HISAL END GRADE_4,
	CASE LOSAL WHEN 3001 THEN LOSAL||'~'||HISAL END GRADE_5
	FROM SAL_GRADE sg;

--5.
SELECT  GRADE , 
	CASE GRADE WHEN 1 THEN LOSAL ||'~'||HISAL ELSE  END GRADE_1,
	CASE GRADE WHEN 2 THEN LOSAL ||'~'||HISAL ELSE  END GRADE_2,
	CASE GRADE WHEN 3 THEN LOSAL ||'~'||HISAL ELSE  END GRADE_3,
	CASE GRADE WHEN 4 THEN LOSAL ||'~'||HISAL ELSE  END GRADE_4,
	CASE GRADE WHEN 5 THEN LOSAL ||'~'||HISAL ELSE  END GRADE_5
	FROM SAL_GRADE sg;


CREATE TABLE SAL_GRADE_TEMP AS SELECT 
	MAX(CASE GRADE WHEN 1 THEN LOSAL ||'~'||HISAL  END) GRADE_1,
	MAX(CASE GRADE WHEN 2 THEN LOSAL ||'~'||HISAL  END) GRADE_2,
	MAX(CASE GRADE WHEN 3 THEN LOSAL ||'~'||HISAL  END) GRADE_3,
	MAX(CASE GRADE WHEN 4 THEN LOSAL ||'~'||HISAL  END) GRADE_4,
	MAX(CASE GRADE WHEN 5 THEN LOSAL ||'~'||HISAL  END) GRADE_5
	FROM SAL_GRADE sg;


SELECT GRADE ,
	MAX(CASE GRADE WHEN 1 THEN LOSAL ||'~'||HISAL
	WHEN 2 THEN LOSAL ||'~'||HISAL 
	WHEN 3 THEN LOSAL ||'~'||HISAL 
	WHEN 4 THEN LOSAL ||'~'||HISAL 
	WHEN 5 THEN LOSAL ||'~'||HISAL  END) GRADE_5
	FROM SAL_GRADE sg
	GROUP BY GRADE;

SELECT sg.GRADE ,
	CASE sg.GRADE 
	WHEN 1 THEN sgt.GRADE_1
	WHEN 2 THEN sgt.GRADE_2
	WHEN 3 THEN sgt.GRADE_3
	WHEN 4 THEN sgt.GRADE_4
	WHEN 5 THEN sgt.GRADE_5
	END LOSAL_HISAL
	FROM SAL_GRADE_TEMP sgt, SAL_GRADE sg  ;

SELECT GRADE,
		DECODE(GRADE,
				1, GRADE_1,
				2, GRADE_2,
				3, GRADE_3,
				4, GRADE_4,
				5, GRADE_5) AS LOSAL_HISAL
	FROM SAL_GRADE_TEMP sgt, SAL_GRADE sg;

SELECT 1 GRADE, GRADE_1 LOSAL_HISAL  FROM SAL_GRADE_TEMP sgt
UNION 
SELECT 2 GRADE, GRADE_2 LOSAL_HISAL  FROM SAL_GRADE_TEMP sgt
UNION
SELECT 3 GRADE, GRADE_3 LOSAL_HISAL  FROM SAL_GRADE_TEMP sgt
UNION
SELECT 4 GRADE, GRADE_4 LOSAL_HISAL  FROM SAL_GRADE_TEMP sgt
UNION
SELECT 5 GRADE, GRADE_5 LOSAL_HISAL  FROM SAL_GRADE_TEMP sgt;

----------------------------------------------
--5일차

--1.
SELECT EMPNO, MGR, SAL, GREATEST(NVL(EMPNO,0),NVL(MGR,0),NVL(SAL,0)) MAX_VALUE, LEAST(NVL(EMPNO,0),NVL(MGR,0),NVL(SAL,0)) MIN_VALUE
	FROM EMP e
	ORDER BY MAX_VALUE DESC;

--2.
SELECT DNAME , CASE WHEN LENGTH(DNAME)>5 THEN SUBSTR(DNAME,1,5) ||'..' ELSE DNAME END "DATA"
	FROM DEPT d ;

--3.
--날짜 계산 연산
SELECT EMPNO , HIREDATE , LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY, TO_DATE('2006/08/05', 'YYYY/MM/DD')-HIREDATE WORK_DAY
	FROM EMP;

SELECT EMPNO, HIREDATE,
      LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY,
      ROUND(TO_DATE('2006/08/05','YYYY/MM/DD')-HIREDATE) WORK_DAY
FROM EMP;

SELECT EMPNO, HIREDATE,
      LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY,
      TO_DATE('20060805')-TO_DATE(TO_CHAR(HIREDATE, 'YYYY-MM-DD')) WORK_DAY 
      FROM EMP e ;

--4.
SELECT EMPNO, HIREDATE, LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY, WORK_DAY
      FROM (SELECT EMPNO , HIREDATE ,TO_DATE('20060805')-TO_DATE(TO_CHAR(HIREDATE, 'YYYY-MM-DD')) WORK_DAY 
      			FROM EMP e 
      				ORDER BY WORK_DAY DESC)
     	WHERE ROWNUM <=1;

     SELECT EMPNO, HIREDATE,
      LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY,
      MAX(TO_DATE('20060805')-TO_DATE(TO_CHAR(HIREDATE, 'YYYY-MM-DD')))  WORK_DAY
      FROM EMP e 
     	WHERE ROWNUM<=1
     	GROUP BY EMPNO, HIREDATE;

--5
SELECT EMPNO, HIREDATE, LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY, WORK_DAY
      FROM (SELECT EMPNO , HIREDATE ,TO_DATE('20060805')-TO_DATE(TO_CHAR(HIREDATE, 'YYYY-MM-DD')) WORK_DAY 
      			FROM EMP e 
      				ORDER BY WORK_DAY DESC)
     	WHERE ROWNUM <=1
UNION
SELECT EMPNO, HIREDATE, LAST_DAY(HIREDATE) HIREDATE_MONTH_LASTDAY, WORK_DAY
      FROM (SELECT EMPNO , HIREDATE ,TO_DATE('20060805')-TO_DATE(TO_CHAR(HIREDATE, 'YYYY-MM-DD')) WORK_DAY 
      			FROM EMP e 
      				ORDER BY WORK_DAY)
     	WHERE  ROWNUM <=1;
     	
--박치현 행님
SELECT EMPNO, HIREDATE , WORK_DAY 
	FROM (
		SELECT a.*, MAX(WORK_DAY) OVER () WORK_DAY_TOP, MIN(WORK_DAY) OVER() WORK_DAY_BOTTOM 
			FROM(SELECT EMPNO, TO_DATE(HIREDATE) HIREDATE,
						TO_DATE('2006/08/05')-TO_DATE(HIREDATE) WORK_DAY
					FROM EMP e) a
		)
	WHERE WORK_DAY = WORK_DAY_TOP OR WORK_DAY = WORK_DAY_BOTTOM;
