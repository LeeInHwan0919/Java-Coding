-- 20220210
-- PIVOT ORACLE 11g 부터 나온 함수

--PIVOT & UNPIVOT
--PIVOT이란? 행을 열로 변환할때 GROUP BY, 집계, CASE문을 사용하여 변경했으나 PIVOT으로 변경이 가능하다
--          GROUP를 통해 테이블 정의, FOR절에서 값을 구분할 조건절을 만들어 컬럼명과 IN으로 값을 생성

--UNPIVOT 이란? 열을 행으로 변환

-- 기존방식으로 PIVOT 처리
CREATE TABLE DATE_TEMP AS SELECT TO_DATE('20210101','YYYYMMDD') + LEVEL -1 DDATE
							FROM DUAL
							CONNECT BY LEVEL-1<=TO_DATE('20221231','YYYYMMDD')-TO_DATE('20210101','YYYYMMDD')  ;
						
						
SELECT TO_CHAR(DDATE, 'YYYYMMDD') 
	FROM DATE_TEMP ;

SELECT TO_CHAR(DDATE, 'YYYY') AS 년도 , 
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '01' THEN 1 ELSE 0 END) AS "01M", 
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '02' THEN 1 ELSE 0 END) AS "02M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '03' THEN 1 ELSE 0 END) AS "03M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '04' THEN 1 ELSE 0 END) AS "04M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '05' THEN 1 ELSE 0 END) AS "05M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '06' THEN 1 ELSE 0 END) AS "06M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '07' THEN 1 ELSE 0 END) AS "07M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '08' THEN 1 ELSE 0 END) AS "08M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '09' THEN 1 ELSE 0 END) AS "09M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '10' THEN 1 ELSE 0 END) AS "10M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '11' THEN 1 ELSE 0 END) AS "11M",
	SUM(CASE TO_CHAR(DDATE, 'MM') WHEN '12' THEN 1 ELSE 0 END) AS "12M"
	FROM DATE_TEMP 
	GROUP BY TO_CHAR(DDATE, 'YYYY');

SELECT *
	FROM (
		SELECT TO_CHAR(DDATE, 'YYYY') 년도,
			DECODE(TO_CHAR(DDATE, 'MM'),'01','1월','02','2월','03','3월','04','4월','05','5월','06','6월','07','7월',
										'08','8월','09','9월','10','10월','11','11월','12','12월') AS MON,
			DDATE 
			FROM DATE_TEMP dt 
		)
		PIVOT 
		(
		COUNT(DDATE) FOR MON IN('1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월')
		);

CREATE TABLE STUDENT(
	JOIN_MONTH VARCHAR2(10),
	NAME VARCHAR2(20)
);

INSERT INTO STUDENT VALUES('1월', '또치');
INSERT INTO STUDENT VALUES('1월', '또치');
INSERT INTO STUDENT VALUES('1월', '둘리');
INSERT INTO STUDENT VALUES('2월', '또치');
INSERT INTO STUDENT VALUES('2월', '둘리');
INSERT INTO STUDENT VALUES('2월', '고길동');

SELECT *
	FROM STUDENT ;

SELECT *
	FROM STUDENT S
	PIVOT ( COUNT(JOIN_MONTH) FOR JOIN_MONTH IN('1월','2월'));

SELECT *
	FROM STUDENT s 

-- UNPIVOT (열을 행으로 변환)
	
SELECT '둘리' NAME, '2' 일월, '1' 이월 FROM DUAL
UNION ALL
SELECT '또치' NAME, '1' 일월, '1' 이월 FROM DUAL;

SELECT COL_NM, COL_VAL
	FROM (
		SELECT '둘리' NAME, '2' ONE, '1' TWO FROM DUAL
		UNION ALL
		SELECT '또치' NAME, '1' ONE, '1' TWO FROM DUAL
		)
	UNPIVOT (
			 COL_VAL FOR COL_NM IN (ONE, TWO)
			)
		ORDER BY 1;

-- 7일차 문제
-- 1.
SELECT SAL, JOB
	FROM EMP e 
	WHERE JOB = 'SALESMAN';

UPDATE EMP SET SAL = SAL+400 WHERE JOB='SALESMAN';

--2.

-- , TO_CHAR(HIREDATE, 'YYYY')+1 
SELECT HIREDATE
	FROM EMP e 
	WHERE SAL > (SELECT AVG(SAL) FROM EMP e );

UPDATE EMP 
	SET HIREDATE = TO_DATE(TO_CHAR(HIREDATE, 'YYYYMMDD')+'00010000')
		WHERE SAL > (SELECT AVG(SAL) FROM EMP e );

--3
SELECT COMM  
	FROM EMP e ;
SELECT SAL , JOB
	FROM EMP e ;
	
UPDATE EMP 
	SET COMM = NVL(COMM,0)+100 , 
		SAL = CASE JOB 
					WHEN 'CLERK' THEN SAL*2 
					WHEN 'MANAGER'THEN SAL*3 
					ELSE SAL*4 
			  END;

--4
SELECT ENAME
	FROM EMP e 
	WHERE ENAME LIKE 'M%';
					
DELETE FROM EMP e WHERE ENAME LIKE'M%';
DELETE FROM EMP e WHERE SUBSTR(ENAME,1,1)='M';

DELETE FROM EMP e WHERE SUBSTR(ENAME,-1,1)='M';-- 뒤에가 M인 사람 찾으려면

--5
SELECT ENAME
	FROM EMP e 
		WHERE SAL > (SELECT AVG(SAL) FROM EMP e );

DELETE FROM EMP e WHERE SAL > (SELECT AVG(SAL) FROM EMP e );

--8일차
--1. ~별로면 GROUP BY + 집계함수 COUNT
SELECT JOB, COUNT(JOB) AS CNT, MIN(HIREDATE) AS FIRST_HIREDATE
	FROM EMP e 
	GROUP BY JOB
	ORDER BY JOB;

--2.
-- INLINE VIEW를 통해서 값을 정제한 후 사용
SELECT YYYYMM HIREDATE, COUNT(*) CNT
	FROM(
		SELECT TO_CHAR(HIREDATE, 'YYYY-MM') YYYYMM
			FROM EMP e 
		)e1
	GROUP BY YYYYMM
	ORDER BY 1;

-- ORDER BY : 컬럼, ALIAS, INDEX, 서브쿼리 => SQL문의 마지막에 실행되기 때문에 FROM 절 혹은 SELECT에 있는 것을 사용할 수 있다.
SELECT TO_CHAR(HIREDATE,'YYYY-MM') AS HIREDATE, COUNT(TO_CHAR(HIREDATE,'YYYY-MM')) AS CNT
	FROM EMP e 
	GROUP BY TO_CHAR(HIREDATE,'YYYY-MM')
	ORDER BY HIREDATE;

--3.
SELECT HIREDATE, CNT
	FROM (SELECT TO_CHAR(HIREDATE,'YYYY-MM') AS HIREDATE, COUNT(TO_CHAR(HIREDATE,'YYYY-MM')) AS CNT
			FROM EMP e 
				GROUP BY TO_CHAR(HIREDATE,'YYYY-MM')
				ORDER BY HIREDATE)
	WHERE CNT>=2; --COST 4
	
	SELECT YYYYMM HIREDATE, COUNT(*) CNT
	FROM(
		SELECT TO_CHAR(HIREDATE, 'YYYY-MM') YYYYMM
			FROM EMP e 
		)e1
	GROUP BY YYYYMM
	HAVING COUNT(YYYYMM) >=2 
	ORDER BY 1;

--4.
-- DEPTNO 숫자형이기 때문에 NVL을 통해서 요구사항에 맞게 되지 않는다.
SELECT DNAME, COUNT(*) CNT , SUM(SAL) SAL
	FROM(
		SELECT DEPTNO , NVL(DNAME , 'NO DEPT'), SAL
			FROM EMP e LEFT OUTER JOIN DEPT d
			USING(DEPTNO)
		)
	GROUP BY DNAME ;

SELECT d2.DNAME, d2.CNT, d2.SAL
	FROM EMP e , DEPT d ,(SELECT NVL(DNAME,'NO DEPT') DNAME, COUNT(NVL(DNAME,'NO DEPT')) CNT, SUM(SAL) SAL
							FROM EMP e , DEPT d
							WHERE e.DEPTNO = d.DEPTNO(+)
							GROUP BY NVL(DNAME,'NO DEPT')) d2
	WHERE e.DEPTNO = d.DEPTNO
	GROUP BY d2.DNAME,d2.CNT, d2.SAL;

SELECT NVL(DNAME,'NO DEPT') , COUNT(NVL(DNAME,'NO DEPT')), SUM(SAL)
	FROM EMP e , DEPT d 
		WHERE e.DEPTNO = d.DEPTNO(+)
		GROUP BY NVL(DNAME,'NO DEPT');

SELECT *
	FROM DEPT d ;

SELECT *
	FROM EMP e , DEPT d 
	WHERE e.DEPTNO = d.DEPTNO;

--5


SELECT MM, NVL(CNT, 0) CNT
	FROM(
		SELECT MM , COUNT(*) CNT
			FROM(
				SELECT TO_NUMBER(TO_CHAR(HIREDATE, 'MM')) MM
				FROM EMP e 
			) e1 
			GROUP BY MM
			ORDER BY 1)
		RIGHT OUTER JOIN
		(SELECT LEVEL MM
			FROM DUAL
			CONNECT BY LEVEL <=12)
	USING(MM)
	ORDER BY MM;
	

SELECT TEAM_ID ,
	SUM(CASE "POSITION"  WHEN 'DF'THEN 1 END) AS DF, 
	SUM(CASE "POSITION"  WHEN 'FW'THEN 1 END) AS FW,
	SUM(CASE "POSITION"  WHEN 'GK'THEN 1 END) AS GK,
	SUM(CASE "POSITION"  WHEN 'MF'THEN 1 END) AS MF,
	SUM(CASE WHEN "POSITION"IS NULL THEN 1 END) "포지션 없음",
	COUNT(*) AS "총인원"
	FROM PLAYER p 
	GROUP BY TEAM_ID ;

SELECT COUNT(SAL), SUM(SAL), AVG(SAL), MAX(SAL), MIN(SAL)  
	FROM EMP e ;

SELECT EMPNO , ENAME , TO_CHAR(HIREDATE, 'YYYY') AS 고용일, DNAME  
	FROM EMP e JOIN DEPT d 
	USING(DEPTNO)
	WHERE JOB ='CLERK';
	
SELECT *
	FROM EMP e ;
	
